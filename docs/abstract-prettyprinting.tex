\documentclass[11pt]{article}
\usepackage{palatino}
\usepackage{amsmath}

\begin{document}

\title{Extended Abstract Machine for Prettyprinting Intermediate Computations}
\maketitle

\section{Compilation Scheme}

\begin{align*}
\mathcal{C}(i) &= \text{INT}(i)\\
\mathcal{C}(b) &= \text{BOOL}(b)\\
\mathcal{C}(a \oplus b) &= \mathcal{C}(a); \mathcal{C}(b); \text{OP}(\oplus)\\
\mathcal{C}(a = b) &= \mathcal{C}(a); \mathcal{C}(b); \text{EQ}\\
\mathcal{C}(\underline{n}) &= \text{ACCESS}(n)\\
\mathcal{C}(\lambda a) &= \text{CLOSURE}(\mathcal{C}(a); \text{RETURN})\\
\mathcal{C}(\texttt{let}\ a\ \texttt{in}\ b) &= \mathcal{C}(a); \text{LET}; \mathcal{C}(b); \text{ENDLET}\\
\mathcal{C}(a b) &= \mathcal{C}(a); \mathcal{C}(b); \text{APPLY}\\
\mathcal{C}(\texttt{if}\ a\ \texttt{then}\ b\ \texttt{else}\ c) &= \mathcal{C}(\lambda b); \mathcal{C}(\lambda c); \mathcal{C}(a); \text{IF}
\end{align*}

e.g \texttt{let x = 1 in let y = 2 in x + y} compiles to:



\section{Evalution Scheme}

\begin{tabular}{l|l|l||l|l|l}
\multicolumn{3}{c}{Machine state before}&\multicolumn{3}{c}{Machine state after}                       \\
Code                    & Env   & Stack                          & Code   & Env    & Stack             \\
$\text{INT}(i);c$       & $e$   & $s$                            & $c$    & $e$    & $i.s$             \\
$\text{BOOL}(b);c$      & $e$   & $s$                            & $c$    & $e$    & $b.s$             \\
$\text{OP}(\oplus);c$   & $e$   & $i.i'.s$                       & $c$    & $e$    & $\oplus(i, i').s$ \\
$\text{EQ};c$           & $e$   & $i.i'.s$                       & $c$    & $e$    & $(i = i').s$      \\
$\text{ACCESS}(n);c$    & $e$   & $s$                            & $c$    & $e$    & $e(n).s$          \\
$\text{CLOSURE}(c');c$  & $e$   & $s$                            & $c$    & $e$    & $c'[e].s$         \\
$\text{LET};c$          & $e$   & $v.s$                          & $c$    & $v.e$  & $s$               \\
$\text{ENDLET};c$       & $v.e$ & $s$                            & $c$    & $e$    & $s$               \\
$\text{APPLY;c}$        & $e$   & $v.c'[e'].s$                   & $c'$   & $v.e'$ & $c.e.s$           \\
$\text{RETURN;c}$       & $e$   & $v.c'.e'.s$                    & $c'$   & $e'$   & $v.s$             \\
$\text{IF;c}$           & $e$   & $\textsf{T}.c'[e'].c''[e''].s$ & $c'$   & $e'$   & $c[e].s$          \\
$\text{IF;c}$           & $e$   & $\textsf{F}.c'[e'].c''[e''].s$ & $c''$  & $e''$  & $c[e].s$          \\
\end{tabular}

\bigskip

\noindent The final result is at the top of the stack when the code is empty.

\section{Decompilation Scheme}

We need to be able to decompile:

\begin{itemize}
\item Any program which has been compiled by the compilation scheme above.
\item Certain incomplete evaluations under the evaluation scheme above. That is to say, given $(c, e, s)$ we can decompile a program which represents the evaluation at that stage.
\end{itemize}

\noindent We need not be able to decompile arbitrary $(c, e, s)$ triples.

\end{document}
