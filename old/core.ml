(* Core / Persvasives *)
open Tinyocaml

(* This contains externals from Core / Pervasives *)
let builtin_output_string = function
  [OutChannel c; String s] -> output_string c s; Unit
| l ->
    failwith
      (Printf.sprintf "builtin_output_string: %s" (Tinyocaml.to_string (Struct l)))

let builtin_print_int = function
  [Int i] -> output_string stdout (string_of_int i); Unit
| _ -> failwith "builtin_print_int"

let builtin_input_line = function
  [InChannel c] -> String (input_line c)
| _ -> failwith "builtin_input_line"

let builtin_int_of_string = function
  [String s] ->
    begin try Int (int_of_string s) with
      e -> failwith "builtin_int_of_string" (* FIXME: A Proper exception here *)
    end
| _ -> failwith "builtin_int_of_string"

let builtin_compare = function
  [x; y] -> Int (compare x y) (* FIXME: Obviously not... *)
| _ -> failwith "builtin_compare"

let builtin_physeq = function
  [x; y] -> Bool (compare x y = 0) (* FIXME: Obviously not... *)
| _ -> failwith "builtin_physeq"

let builtin_asr = function
  [Int x; Int y] -> Int (x asr y)
| _ -> failwith "builtin_asr"

(* The initial asterisk will be used to elide these variables when not showing
pervasives in the output. When showing pervasives, we just remove the asterisk. *)
let mk name f =
  (name, Fun (PatVar "__PER__x", CallBuiltIn (name, [Var "__PER__x"], f), [])) (* FIXME Add environment *)

let mk2 name f =
  (name,
   Fun (PatVar "__PER__x",
     Fun (PatVar "__PER__y", CallBuiltIn (name, [Var "__PER__x"; Var "__PER__y"], f), []), [])) (* FIXME Add environement *)

(* String to tinyocaml *)
let make_tiny s =
  match
    s |> Lexing.from_string |> Parse.implementation |> of_real_ocaml
  with
    Struct ([LetDef (_, [(PatVar n, x)])]) -> (n, x)
  | Struct ([ExceptionDef (n, _) as h]) -> (n, h)
  | exception e -> print_string s; print_newline (); raise e
  | _ -> failwith "make_tiny"

(* This contains pure ocaml functions for things in Pervasives. FIXME:
Autogenerate these by reading pervasives.ml(i) from the OCaml installation. *)
let pervasives =
  [make_tiny "let ref = fun __PER__x -> {contents = __PER__x}";
   make_tiny "let ( ! ) = fun __PER__x -> __PER__x.contents";
   make_tiny "let ( := ) = fun __PER__a -> fun __PER__b -> __PER__a.contents <- __PER__b";
   make_tiny "let rec ( @ ) __PER__l1 __PER__l2 = match __PER__l1 with [] -> __PER__l2 | __PER__hd :: __PER__tl -> __PER__hd :: (__PER__tl @ __PER__l2)";
   mk2 "output_string" builtin_output_string;
   make_tiny "let print_string = fun __PER__x -> output_string stdout __PER__x";
   mk "print_int" builtin_print_int;
   mk "int_of_string" builtin_int_of_string;
   mk "input_line" builtin_input_line;
   mk2 "compare" builtin_compare;
   mk2 "==" builtin_physeq;
   mk2 "asr" builtin_asr;
   make_tiny "let failwith = fun __PER__s -> raise (Failure __PER__s)";
   make_tiny "let invalid_arg = fun __PER__s -> raise (Invalid_argument __PER__s)"]

(* Core exceptions. These cannot be autogenerated without access to an
OCaml source tree, so we list them explicitly. We don't need the core types like
int and format6 etc, because we deal with them explicitly in Tinyocaml. *)
let core =
  [make_tiny "exception Match_failure of string * int * int";
   make_tiny "exception Assert_failure of string * int * int";
   make_tiny "exception Invalid_argument of string";
   make_tiny "exception Failure of string";
   make_tiny "exception Not_found";
   make_tiny "exception Out_of_memory";
   make_tiny "exception Stack_overflow";
   make_tiny "exception Sys_error of string";
   make_tiny "exception End_of_file";
   make_tiny "exception Division_by_zero";
   make_tiny "exception Sys_blocked_io";
   make_tiny "exception Undefined_recursive_module of string * int * int"]


